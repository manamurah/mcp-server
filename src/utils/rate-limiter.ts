/**\n * Rate Limiter for ManaMurah MCP Server\n * Implements simple in-memory rate limiting for MCP requests\n */\nexport class RateLimiter {\n  private requests: Map<string, number[]>;\n  private readonly windowMs: number;\n  private readonly maxRequests: number;\n  private readonly maxRequestsPerHour: number;\n\n  constructor() {\n    this.requests = new Map();\n    this.windowMs = 60 * 1000; // 1 minute window\n    this.maxRequests = 10; // 10 requests per minute\n    this.maxRequestsPerHour = 100; // 100 requests per hour\n  }\n\n  /**\n   * Check if client is within rate limits\n   */\n  async checkLimit(clientId: string): Promise<boolean> {\n    const now = Date.now();\n    const clientRequests = this.requests.get(clientId) || [];\n\n    // Clean up old requests (older than 1 hour)\n    const hourAgo = now - (60 * 60 * 1000);\n    const recentRequests = clientRequests.filter(timestamp => timestamp > hourAgo);\n\n    // Check hourly limit\n    if (recentRequests.length >= this.maxRequestsPerHour) {\n      return false;\n    }\n\n    // Check per-minute limit\n    const minuteAgo = now - this.windowMs;\n    const recentMinuteRequests = recentRequests.filter(timestamp => timestamp > minuteAgo);\n    \n    if (recentMinuteRequests.length >= this.maxRequests) {\n      return false;\n    }\n\n    // Add current request\n    recentRequests.push(now);\n    this.requests.set(clientId, recentRequests);\n\n    return true;\n  }\n\n  /**\n   * Get remaining requests for client\n   */\n  getRemainingRequests(clientId: string): { perMinute: number; perHour: number } {\n    const now = Date.now();\n    const clientRequests = this.requests.get(clientId) || [];\n\n    const minuteAgo = now - this.windowMs;\n    const hourAgo = now - (60 * 60 * 1000);\n\n    const recentMinuteRequests = clientRequests.filter(timestamp => timestamp > minuteAgo).length;\n    const recentHourRequests = clientRequests.filter(timestamp => timestamp > hourAgo).length;\n\n    return {\n      perMinute: Math.max(0, this.maxRequests - recentMinuteRequests),\n      perHour: Math.max(0, this.maxRequestsPerHour - recentHourRequests)\n    };\n  }\n\n  /**\n   * Clean up old entries to prevent memory leaks\n   */\n  cleanup(): void {\n    const now = Date.now();\n    const hourAgo = now - (60 * 60 * 1000);\n\n    for (const [clientId, requests] of this.requests.entries()) {\n      const recentRequests = requests.filter(timestamp => timestamp > hourAgo);\n      \n      if (recentRequests.length === 0) {\n        this.requests.delete(clientId);\n      } else {\n        this.requests.set(clientId, recentRequests);\n      }\n    }\n  }\n\n  /**\n   * Get rate limit status for client\n   */\n  getStatus(clientId: string): {\n    allowed: boolean;\n    remaining: { perMinute: number; perHour: number };\n    resetTime: { perMinute: number; perHour: number };\n  } {\n    const now = Date.now();\n    const remaining = this.getRemainingRequests(clientId);\n    \n    return {\n      allowed: remaining.perMinute > 0 && remaining.perHour > 0,\n      remaining,\n      resetTime: {\n        perMinute: Math.ceil((now + this.windowMs) / 1000),\n        perHour: Math.ceil((now + (60 * 60 * 1000)) / 1000)\n      }\n    };\n  }\n}