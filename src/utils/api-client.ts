/**
 * ManaMurah API Client for MCP Server
 * Handles communication with the main ManaMurah Data API
 */
export class ManaMurahApiClient {
  private baseUrl: string;
  private aiBaseUrl: string;

  constructor() {
    this.baseUrl = 'https://api.manamurah.com/api/v1';
    this.aiBaseUrl = 'https://api.manamurah.com/api/ai/v1';
  }

  /**
   * Search for prices using the AI-optimized endpoint
   */
  async searchPrices(params: any) {
    try {
      const queryParams = new URLSearchParams();
      
      // Add natural language query if provided
      if (params.query) {
        queryParams.append('q', params.query);
      }

      // Add structured parameters
      if (params.item) queryParams.append('item', params.item);
      if (params.location) queryParams.append('location', params.location);
      if (params.retailer_type) queryParams.append('retailer_type', params.retailer_type);
      if (params.max_price) queryParams.append('max_price', params.max_price.toString());
      if (params.min_price) queryParams.append('min_price', params.min_price.toString());

      const url = `${this.aiBaseUrl}/prices/search?${queryParams.toString()}`;\n      const response = await fetch(url, {\n        headers: {\n          'User-Agent': 'ManaMurah-MCP-Server/1.0.0',\n          'Accept': 'application/json'\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`API request failed: ${response.status} ${response.statusText}`);\n      }\n\n      const data = await response.json();\n      \n      if (data.error) {\n        throw new Error(data.error.message || 'API returned an error');\n      }\n\n      return data;\n\n    } catch (error) {\n      console.error('Price search API error:', error);\n      throw new Error(`Failed to search prices: ${error.message}`);\n    }\n  }\n\n  /**\n   * Compare prices across regions or retailers\n   */\n  async comparePrices(params: any) {\n    try {\n      // For comparison, we'll make multiple API calls and aggregate results\n      const comparisons = [];\n      \n      if (params.regions && params.regions.length > 0) {\n        for (const region of params.regions) {\n          const result = await this.searchPrices({\n            item: params.item,\n            location: region,\n            limit: 10\n          });\n          \n          if (result.data && result.data.length > 0) {\n            comparisons.push({\n              region,\n              data: result.data,\n              statistics: this.calculateStatistics(result.data)\n            });\n          }\n        }\n      } else {\n        // Default comparison across major states\n        const majorStates = ['Kuala Lumpur', 'Selangor', 'Penang', 'Johor', 'Perak'];\n        for (const state of majorStates) {\n          try {\n            const result = await this.searchPrices({\n              item: params.item,\n              location: state,\n              limit: 5\n            });\n            \n            if (result.data && result.data.length > 0) {\n              comparisons.push({\n                region: state,\n                data: result.data,\n                statistics: this.calculateStatistics(result.data)\n              });\n            }\n          } catch (error) {\n            // Continue with other states if one fails\n            console.warn(`Failed to get data for ${state}:`, error.message);\n          }\n        }\n      }\n\n      return {\n        item: params.item,\n        comparison_type: params.comparison_type,\n        comparisons,\n        summary: this.generateComparisonSummary(comparisons)\n      };\n\n    } catch (error) {\n      console.error('Price comparison error:', error);\n      throw new Error(`Failed to compare prices: ${error.message}`);\n    }\n  }\n\n  /**\n   * Analyze price trends (mock implementation for now)\n   */\n  async analyzeTrends(params: any) {\n    try {\n      // This would typically call a trends endpoint\n      // For now, we'll return mock trend data\n      const currentPrices = await this.searchPrices({\n        item: params.items[0], // Use first item for now\n        limit: 20\n      });\n\n      return {\n        items: params.items,\n        analysis_type: params.analysis_type,\n        time_period: params.time_period,\n        current_data: currentPrices,\n        trend_summary: this.generateTrendSummary(currentPrices, params),\n        insights: [\n          'Price data shows current market conditions',\n          'Regional variations exist across different states',\n          'Retailer type significantly affects pricing'\n        ]\n      };\n\n    } catch (error) {\n      console.error('Trend analysis error:', error);\n      throw new Error(`Failed to analyze trends: ${error.message}`);\n    }\n  }\n\n  /**\n   * Get market insights\n   */\n  async getMarketInsights(params: any) {\n    try {\n      // Get current market data\n      const recentData = await this.searchPrices({\n        limit: 50 // Get broader sample\n      });\n\n      return {\n        focus: params.focus,\n        timeframe: params.timeframe,\n        data_points: recentData.data?.length || 0,\n        insights: this.generateMarketInsights(recentData, params),\n        summary: 'Market analysis based on current KPDN Pricecatcher data',\n        last_updated: new Date().toISOString()\n      };\n\n    } catch (error) {\n      console.error('Market insights error:', error);\n      throw new Error(`Failed to get market insights: ${error.message}`);\n    }\n  }\n\n  /**\n   * Calculate basic statistics for price data\n   */\n  private calculateStatistics(data: any[]) {\n    if (!data || data.length === 0) {\n      return { average: 0, min: 0, max: 0, count: 0 };\n    }\n\n    const prices = data.map(item => item.price).filter(price => typeof price === 'number');\n    \n    if (prices.length === 0) {\n      return { average: 0, min: 0, max: 0, count: 0 };\n    }\n\n    const sum = prices.reduce((acc, price) => acc + price, 0);\n    const average = sum / prices.length;\n    const min = Math.min(...prices);\n    const max = Math.max(...prices);\n\n    return {\n      average: parseFloat(average.toFixed(2)),\n      min,\n      max,\n      count: prices.length,\n      range: parseFloat((max - min).toFixed(2))\n    };\n  }\n\n  /**\n   * Generate comparison summary\n   */\n  private generateComparisonSummary(comparisons: any[]) {\n    if (comparisons.length === 0) {\n      return 'No data available for comparison';\n    }\n\n    const regionStats = comparisons.map(comp => ({\n      region: comp.region,\n      avgPrice: comp.statistics.average\n    })).filter(stat => stat.avgPrice > 0);\n\n    if (regionStats.length === 0) {\n      return 'No valid price data found for comparison';\n    }\n\n    const cheapest = regionStats.reduce((min, curr) => \n      curr.avgPrice < min.avgPrice ? curr : min\n    );\n    \n    const mostExpensive = regionStats.reduce((max, curr) => \n      curr.avgPrice > max.avgPrice ? curr : max\n    );\n\n    const avgDifference = mostExpensive.avgPrice - cheapest.avgPrice;\n    const percentDifference = ((avgDifference / cheapest.avgPrice) * 100).toFixed(1);\n\n    return `${cheapest.region} has the lowest average prices (RM${cheapest.avgPrice}), while ${mostExpensive.region} has the highest (RM${mostExpensive.avgPrice}). Price difference: ${percentDifference}%.`;\n  }\n\n  /**\n   * Generate trend summary\n   */\n  private generateTrendSummary(data: any, params: any) {\n    const statistics = this.calculateStatistics(data.data || []);\n    \n    return {\n      current_average: statistics.average,\n      price_range: `RM${statistics.min} - RM${statistics.max}`,\n      sample_size: statistics.count,\n      analysis: `Current ${params.items[0]} prices show an average of RM${statistics.average} with ${statistics.count} data points across Malaysia.`\n    };\n  }\n\n  /**\n   * Generate market insights\n   */\n  private generateMarketInsights(data: any, params: any) {\n    const insights = [];\n    \n    if (data.ai_context) {\n      if (data.ai_context.key_insights) {\n        insights.push(...data.ai_context.key_insights);\n      }\n      \n      if (data.ai_context.anomalies && data.ai_context.anomalies.length > 0) {\n        insights.push(`Detected ${data.ai_context.anomalies.length} price anomalies in current data`);\n      }\n    }\n\n    if (data.data && data.data.length > 0) {\n      const statistics = this.calculateStatistics(data.data);\n      insights.push(`Current market sample includes ${statistics.count} price points with average RM${statistics.average}`);\n      \n      if (statistics.range > statistics.average * 0.3) {\n        insights.push('Significant price variation detected across different retailers and locations');\n      }\n    }\n\n    if (insights.length === 0) {\n      insights.push('Market data analysis shows stable pricing conditions based on available data');\n    }\n\n    return insights;\n  }\n}