/**\n * Response Formatter for ManaMurah MCP Server\n * Formats API responses for optimal display in Claude Desktop and other MCP clients\n */\nexport class ResponseFormatter {\n\n  /**\n   * Format price search results for MCP display\n   */\n  formatPriceResults(apiResponse: any, originalQuery?: string) {\n    try {\n      if (!apiResponse || !apiResponse.data) {\n        return this.formatError('No price data available');\n      }\n\n      const { data, ai_context, narrative, meta } = apiResponse;\n      \n      // Create formatted response text\n      let responseText = '';\n\n      // Add header with query context\n      if (originalQuery) {\n        responseText += `# Price Search Results: \"${originalQuery}\"\n\n`;\n      } else {\n        responseText += `# Malaysian Price Data\n\n`;\n      }\n\n      // Add summary from AI context\n      if (ai_context?.summary) {\n        responseText += `📊 **Summary**: ${ai_context.summary}\n\n`;\n      }\n\n      // Add key insights\n      if (ai_context?.key_insights && ai_context.key_insights.length > 0) {\n        responseText += `💡 **Key Insights**:\n`;\n        ai_context.key_insights.forEach((insight: string) => {\n          responseText += `• ${insight}\n`;\n        });\n        responseText += '\n';\n      }\n\n      // Add price statistics if available\n      if (ai_context?.price_statistics) {\n        const stats = ai_context.price_statistics;\n        responseText += `📈 **Price Statistics**:\n`;\n        responseText += `• Average: RM${stats.average}\n`;\n        responseText += `• Range: RM${stats.min} - RM${stats.max}\n`;\n        if (stats.range_percentage) {\n          responseText += `• Price Variation: ${stats.range_percentage}%\n`;\n        }\n        responseText += '\n';\n      }\n\n      // Add detailed price data\n      if (data.length > 0) {\n        responseText += `## Detailed Price Information\n\n`;\n        \n        data.slice(0, 10).forEach((item: any, index: number) => {\n          responseText += `### ${index + 1}. ${item.item || 'Item'}\n`;\n          responseText += `• **Price**: RM${item.price}\n`;\n          responseText += `• **Store**: ${item.premise || 'Unknown'}\n`;\n          if (item.chain) {\n            responseText += `• **Chain**: ${item.chain}\n`;\n          }\n          responseText += `• **Location**: ${item.address || item.state || 'Unknown'}\n`;\n          if (item.retailer_type) {\n            responseText += `• **Type**: ${this.capitalizeFirstLetter(item.retailer_type)}\n`;\n          }\n          if (item.date) {\n            responseText += `• **Date**: ${item.date}\n`;\n          }\n          responseText += '\n';\n        });\n\n        if (data.length > 10) {\n          responseText += `*Showing first 10 of ${data.length} results*\n\n`;\n        }\n      }\n\n      // Add narrative explanation\n      if (narrative?.detailed) {\n        responseText += `## Analysis\n${narrative.detailed}\n\n`;\n      }\n\n      // Add suggested questions\n      if (apiResponse.suggested_questions && apiResponse.suggested_questions.length > 0) {\n        responseText += `## 🤔 You might also ask:\n`;\n        apiResponse.suggested_questions.forEach((question: string) => {\n          responseText += `• ${question}\n`;\n        });\n        responseText += '\n';\n      }\n\n      // Add data source information\n      responseText += `---\n**Data Source**: Official KPDN Pricecatcher via [OpenDOSM](https://open.dosm.gov.my)`;\n      if (meta?.last_updated) {\n        responseText += ` | Last Updated: ${new Date(meta.last_updated).toLocaleDateString()}`;\n      }\n      \n      return {\n        content: [\n          {\n            type: 'text',\n            text: responseText\n          }\n        ]\n      };\n\n    } catch (error) {\n      return this.formatError(`Error formatting price results: ${error.message}`);\n    }\n  }\n\n  /**\n   * Format price comparison results\n   */\n  formatComparisonResults(comparisonData: any, originalInput: any) {\n    try {\n      let responseText = `# Price Comparison: ${comparisonData.item || 'Items'}\n\n`;\n\n      if (comparisonData.summary) {\n        responseText += `📊 **Summary**: ${comparisonData.summary}\n\n`;\n      }\n\n      if (comparisonData.comparisons && comparisonData.comparisons.length > 0) {\n        responseText += `## Regional Comparison\n\n`;\n        \n        comparisonData.comparisons.forEach((comp: any, index: number) => {\n          responseText += `### ${index + 1}. ${comp.region}\n`;\n          \n          if (comp.statistics) {\n            const stats = comp.statistics;\n            responseText += `• **Average Price**: RM${stats.average}\n`;\n            responseText += `• **Price Range**: RM${stats.min} - RM${stats.max}\n`;\n            responseText += `• **Sample Size**: ${stats.count} price points\n`;\n            \n            if (stats.range > 0) {\n              responseText += `• **Price Variation**: RM${stats.range}\n`;\n            }\n          }\n          \n          // Show a few sample prices\n          if (comp.data && comp.data.length > 0) {\n            responseText += `• **Sample Prices**: `;\n            const samplePrices = comp.data.slice(0, 3).map((item: any) => \n              `RM${item.price} (${item.premise || 'Store'})`\n            ).join(', ');\n            responseText += samplePrices;\n            if (comp.data.length > 3) {\n              responseText += ` and ${comp.data.length - 3} more...`;\n            }\n          }\n          \n          responseText += '\n\n';\n        });\n      }\n\n      // Add comparison insights\n      if (comparisonData.comparisons.length > 1) {\n        responseText += `## 💡 Comparison Insights\n`;\n        \n        const avgPrices = comparisonData.comparisons\n          .filter((comp: any) => comp.statistics?.average > 0)\n          .map((comp: any) => ({ region: comp.region, avg: comp.statistics.average }));\n        \n        if (avgPrices.length > 0) {\n          const cheapest = avgPrices.reduce((min, curr) => curr.avg < min.avg ? curr : min);\n          const mostExpensive = avgPrices.reduce((max, curr) => curr.avg > max.avg ? curr : max);\n          \n          responseText += `• **Most Affordable**: ${cheapest.region} (RM${cheapest.avg} average)\n`;\n          responseText += `• **Most Expensive**: ${mostExpensive.region} (RM${mostExpensive.avg} average)\n`;\n          \n          if (cheapest.region !== mostExpensive.region) {\n            const savings = mostExpensive.avg - cheapest.avg;\n            const percentage = ((savings / mostExpensive.avg) * 100).toFixed(1);\n            responseText += `• **Potential Savings**: RM${savings.toFixed(2)} (${percentage}%) by choosing ${cheapest.region}\n`;\n          }\n        }\n      }\n\n      responseText += `\n---\n**Data Source**: Official KPDN Pricecatcher data`;\n      \n      return {\n        content: [\n          {\n            type: 'text',\n            text: responseText\n          }\n        ]\n      };\n\n    } catch (error) {\n      return this.formatError(`Error formatting comparison results: ${error.message}`);\n    }\n  }\n\n  /**\n   * Format trend analysis results\n   */\n  formatTrendResults(trendData: any, originalInput: any) {\n    try {\n      let responseText = `# Trend Analysis: ${trendData.items?.join(', ') || 'Items'}\n\n`;\n\n      responseText += `📈 **Analysis Type**: ${this.capitalizeFirstLetter(trendData.analysis_type || 'trend')}\n`;\n      responseText += `📅 **Time Period**: ${this.formatTimePeriod(trendData.time_period || 'recent')}\n\n`;\n\n      if (trendData.trend_summary) {\n        const summary = trendData.trend_summary;\n        responseText += `## Current Market Status\n`;\n        responseText += `• **Current Average**: RM${summary.current_average}\n`;\n        responseText += `• **Price Range**: ${summary.price_range}\n`;\n        responseText += `• **Data Points**: ${summary.sample_size} price observations\n\n`;\n        \n        if (summary.analysis) {\n          responseText += `**Analysis**: ${summary.analysis}\n\n`;\n        }\n      }\n\n      if (trendData.insights && trendData.insights.length > 0) {\n        responseText += `## 🔍 Key Insights\n`;\n        trendData.insights.forEach((insight: string) => {\n          responseText += `• ${insight}\n`;\n        });\n        responseText += '\n';\n      }\n\n      // Add current data if available\n      if (trendData.current_data?.data && trendData.current_data.data.length > 0) {\n        responseText += `## Current Price Sample\n`;\n        const sampleData = trendData.current_data.data.slice(0, 5);\n        \n        sampleData.forEach((item: any, index: number) => {\n          responseText += `${index + 1}. **${item.item}** - RM${item.price} at ${item.premise || 'Store'}`;\n          if (item.state) {\n            responseText += ` (${item.state})`;\n          }\n          responseText += '\n';\n        });\n        \n        if (trendData.current_data.data.length > 5) {\n          responseText += `*Showing 5 of ${trendData.current_data.data.length} current prices*\n`;\n        }\n        responseText += '\n';\n      }\n\n      responseText += `---\n**Note**: Trend analysis is based on available current data. Historical trend data requires additional data collection over time.`;\n      \n      return {\n        content: [\n          {\n            type: 'text',\n            text: responseText\n          }\n        ]\n      };\n\n    } catch (error) {\n      return this.formatError(`Error formatting trend results: ${error.message}`);\n    }\n  }\n\n  /**\n   * Format market insights results\n   */\n  formatInsightResults(insightData: any, originalInput: any) {\n    try {\n      let responseText = `# Market Insights\n\n`;\n\n      responseText += `🎯 **Focus**: ${this.capitalizeFirstLetter(insightData.focus || 'overview')}\n`;\n      responseText += `📅 **Timeframe**: ${this.formatTimePeriod(insightData.timeframe || 'current')}\n`;\n      responseText += `📊 **Data Points**: ${insightData.data_points || 'Various'} price observations\n\n`;\n\n      if (insightData.summary) {\n        responseText += `## Summary\n${insightData.summary}\n\n`;\n      }\n\n      if (insightData.insights && insightData.insights.length > 0) {\n        responseText += `## 💡 Market Insights\n`;\n        insightData.insights.forEach((insight: string, index: number) => {\n          responseText += `${index + 1}. ${insight}\n`;\n        });\n        responseText += '\n';\n      }\n\n      if (insightData.last_updated) {\n        responseText += `**Last Updated**: ${new Date(insightData.last_updated).toLocaleString()}\n\n`;\n      }\n\n      responseText += `---\n**Data Source**: Real-time analysis of KPDN Pricecatcher data`;\n      \n      return {\n        content: [\n          {\n            type: 'text',\n            text: responseText\n          }\n        ]\n      };\n\n    } catch (error) {\n      return this.formatError(`Error formatting insight results: ${error.message}`);\n    }\n  }\n\n  /**\n   * Format error messages for MCP display\n   */\n  formatError(errorMessage: string) {\n    return {\n      content: [\n        {\n          type: 'text',\n          text: `❌ **Error**: ${errorMessage}\n\n💡 **Suggestions**:\n• Try a different search query\n• Check spelling of item names or locations\n• Use general terms like \"rice in Kuala Lumpur\"\n• Contact support if the issue persists\n\n**Example queries**:\n• \"rice prices in Penang\"\n• \"cheapest chicken in Selangor\"\n• \"compare cooking oil prices across states\"`\n        }\n      ]\n    };\n  }\n\n  /**\n   * Utility: Capitalize first letter of a string\n   */\n  private capitalizeFirstLetter(str: string): string {\n    return str.charAt(0).toUpperCase() + str.slice(1).replace(/_/g, ' ');\n  }\n\n  /**\n   * Utility: Format time period for display\n   */\n  private formatTimePeriod(period: string): string {\n    const periodMap: Record<string, string> = {\n      'last_week': 'Last Week',\n      'last_month': 'Last Month',\n      'last_quarter': 'Last Quarter',\n      'today': 'Today',\n      'this_week': 'This Week',\n      'this_month': 'This Month',\n      'recent': 'Recent Data',\n      'current': 'Current'\n    };\n    \n    return periodMap[period] || this.capitalizeFirstLetter(period);\n  }\n}